package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"

	"dario.cat/mergo"
	"github.com/PICT-LibraryAutomation/granthpal/graph"
	"github.com/PICT-LibraryAutomation/granthpal/remote/models"
	"github.com/PICT-LibraryAutomation/granthpal/utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, inp graph.CreateUserInp) (*graph.User, error) {
	user := models.User{
		ID:           inp.ID,
		Kind:         inp.Kind,
		Name:         inp.Name,
		Email:        inp.Email,
		Phone:        inp.Phone,
		PasswordHash: inp.PasswordHash,
	}

	if err := r.Remote.Save(&user).Error; err != nil {
		return nil, err
	}

	return user.ToGraphQL(), nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*string, error) {
	if err := r.Remote.Delete(&models.User{ID: id}).Error; err != nil {
		return nil, err
	}

	return &id, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, inp graph.UpdateUserInp) (*graph.User, error) {
	var u models.User
	if err := r.Remote.First(&u, "id = ?", inp.ID).Error; err != nil {
		return nil, err
	}

	if err := mergo.Merge(&u, inp, mergo.WithOverride); err != nil {
		return nil, err
	}

	if err := r.Remote.Save(&u).Error; err != nil {
		return nil, err
	}

	return u.ToGraphQL(), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*graph.User, error) {
	var user models.User
	if err := r.Remote.First(&user, "id = ?", id).Error; err != nil {
		return nil, err
	}

	return user.ToGraphQL(), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*graph.User, error) {
	var users []models.User
	if err := r.Remote.Find(&users).Error; err != nil {
		return nil, err
	}

	return utils.Map(users, func(u models.User) *graph.User {
		return u.ToGraphQL()
	}), nil
}

// IssueRecords is the resolver for the issueRecords field.
func (r *userResolver) IssueRecords(ctx context.Context, obj *graph.User) ([]*graph.IssueRecord, error) {
	var records []models.IssueRecord
	if err := r.Remote.First(&models.User{ID: obj.ID}).Association("IssueRecords").Find(&records); err != nil {
		return nil, err
	}

	return utils.Map(records, func(r models.IssueRecord) *graph.IssueRecord {
		return r.ToGraphQL()
	}), nil
}

// Payments is the resolver for the payments field.
func (r *userResolver) Payments(ctx context.Context, obj *graph.User) ([]*graph.Payment, error) {
	var payments []models.Payment
	if err := r.Remote.First(&models.User{ID: obj.ID}).Association("Payments").Find(&payments); err != nil {
		return nil, err
	}

	return utils.Map(payments, func(p models.Payment) *graph.Payment {
		return p.ToGraphQL()
	}), nil
}

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
